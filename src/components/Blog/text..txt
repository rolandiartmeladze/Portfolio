გა მარჯობა მოდი დღეს ვისაუბროთ ჩემი  portfolio > პროექტის შესახებ რომელიც შედგება წინა და უკანა ნაწილისგან მე მოგიყვები მის შეაებ გაჩვენებ ჩემს იერ დაწერილ კოდს რომელიც გამართულად მუშაობს ლოკალურ მოწყობილობაზე ეს არის რეაქთ ტაიპსკრიპტზე წინა ნაწილი რომელიც იღებს და ამუშავებს მოთხოვნებს უკანა ნაწილისთვის  აქ მაქვს მომხმარებლისთვის შემდეგი სახის ქმედების შესაძლებლობა ავტორიზაცია Login => შესაძლებელია ავტორიზაცია როგორც მომხმარებლის სახელითა და პაროლის შეყვანით , ამ მეთოდს უკანა ნაწილში ემსახურება jsw Token  აუტორიზაციის მეთოდი და აბრუნებს ავტორიზებული მომხმარებლისთვის ტოკენს , ასევე შესაძლებელია allauth  აპიკაციის გამოყენებით ავტორიზაცია გუგლის ან სხვა პროვაიდერის გამოყენებით  { const Login = async (User: any) => {
  console.log(User);
  try {
    const response = await fetch("http://127.0.0.1:8000/api/login/", {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify(User),
      credentials: "include",
      });

    if (response.ok) {
      const data = await response.json();
      console.log(data);

      const user = {
        email: data.email,
        lastname: data.lastname,
        firstname: data.firstname,
        username: data.username,

      }

      localStorage.setItem("accessToken", data.access);
      localStorage.setItem("refreshToken", data.refresh);
      localStorage.setItem("user", JSON.stringify(user));
      
      return true; 
    } else {
      return false; 
    }
  } catch (error) {
    console.error("Error during login:", error);
    return false; 
  }
};

export default Login;
 } ;  => 
const Author = ({ authorised, setAuthorised }: Props) => {
  const [loading, setLoading] = useState<boolean>(false);

  const [login, setLogin] = useState<boolean>(true);

  const [username, setUsername] = useState<string>("");
  const [password, setPassword] = useState<string>("");
  const [loginStatus, setLoginStatus] = useState<string>("");

  const handleLogin = async () => {
    setLoading(true);

    const userCredentials = {
      username: username,
      password: password,
    };

    try {
      const loginResult = await Login(userCredentials);

      if (loginResult) {
        setLoginStatus("Login successful!");

        setAuthorised(true);
        setLoading(false);
      } else {
      }
    } catch (error) {
      console.error("Login error:", error);
      setLoginStatus("Error during login.");
    }
  };

  return (
    <>
      {!authorised && !login ? (
        <Form  authorised={authorised} className="form signup">
          <Register setLogin={setLogin} />
        </Form>
      ) : (
        <Form authorised={authorised} className="form login">
          <h2>Login Form</h2>

          {loading && (
            <Loading loading={loading}>
              <FaRegSmileWink />
              <h6> Thanks for waiting </h6>
            </Loading>
          )}

          <div className="line-cont">
            <RxAvatar />
            <input
              id="username"
              value={username}
              onChange={(e) => setUsername(e.target.value)}
              type="text"
              placeholder="Username"
            />
          </div>

          <div className="line-cont">
            <RiLockPasswordFill />
            <input
              id="password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              type="password"
              placeholder="Password"
            />
          </div>

          <div className="btn-cont">
            <button
              onClick={() => {
                setLogin(false);
              }}
              type="button"
            >
              Sign Up
            </button>
            <button onClick={handleLogin} type="button">
              Login
            </button>
          </div>

          <div className="auth">
            <LoginWith />
          </div>

          {loginStatus && <p>{loginStatus}</p>}
        </Form>
      )}
    </>
  );
};

export default Author; ;    ასევე მომხმარებელს შესაძლებლობა აქვს შექმნას ახალი ანგარიშე = {
const Register = ({ setLogin }: Props) => {
  const usernameRef = useRef<HTMLInputElement>(null);
  const firstnameRef = useRef<HTMLInputElement>(null);
  const lastnameRef = useRef<HTMLInputElement>(null);
  const emailRef = useRef<HTMLInputElement>(null);
  const passwordRef = useRef<HTMLInputElement>(null);
  const password2Ref = useRef<HTMLInputElement>(null);

  const SignUpBtn = async () => {
    // e.preventDefault();
    const user = {
      username: usernameRef.current?.value,
      first_name: firstnameRef.current?.value,
      last_name: lastnameRef.current?.value,
      email: emailRef.current?.value,
      password: passwordRef.current?.value,
      password2: password2Ref.current?.value,
    };

    console.log(user)

    if (user.password !== user.password2) {
      alert('Passwords do not match');
      return;
    }


    try {
      const response = await fetch('http://localhost:8000/api/register/', {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify(user),
      });

      if (!response.ok) {
        const errData = await response.json();
        throw new Error(errData.detail || 'Registration failed');
      }

      const data = await response.json();
      console.log(data);
      if (data.token) {
        // const decodedToken = jwtDecode(data.token);
        // console.log('Decoded token info:', decodedToken);
      }

      alert('Registration successful! Please log in.');
    } catch (error: any) {
      console.error('Registration error', error);
      alert(error.message);
    }
  };

  const UserInfo: UserProps[] = [
    { id: 'username', type: 'text', placeholder: 'Username', icon: FaUserAlt },
    { id: 'firstname', type: 'text', placeholder: 'Enter First Name', icon: IoTextSharp },
    { id: 'lastname', type: 'text', placeholder: 'Enter Last Name', icon: IoTextSharp },
    { id: 'email', type: 'email', placeholder: 'Enter Email', icon: MdEmail },
    { id: 'password', type: 'password', placeholder: 'Enter Password', icon: RiLockPasswordFill },
    { id: 'password2', type: 'password', placeholder: 'Confirm Password', icon: FaRepeat },
  ];

  const SignUpForm = () => {
    const refs = {
      username: usernameRef,
      firstname: firstnameRef,
      lastname: lastnameRef,
      email: emailRef,
      password: passwordRef,
      password2: password2Ref,
    };

    return (
      <>
        {UserInfo.map((item, index) => (
          <div className="line-cont" key={index}>
            <item.icon />
            <input
              id={item.id}
              type={item.type}
              placeholder={item.placeholder}
              ref={refs[item.id as keyof typeof refs]} // Use ref to store the input element
            />
          </div>
        ))}
      </>
    );
  };

  const login = () =>{

setLogin(true);

 }


  return (
<>
      <h2>Register Form</h2>
      <SignUpForm />
      <div className="btn-cont">
        <button onClick={SignUpBtn}>Sign Up</button>
        <button type='button' onClick={login}>Login</button>

      </div>
      <div className="auth">
       <LoginWith />
      </div>
</>    
  );
};

export default Register;  };   როდესაც ანგარიში შეიქმნება მომხმარებელი შეძლებს ავტორიზაციას jwt საშუალებით    .  ავტორიზებული მომხმაფრებლისთვის ხელმისაწვდომი იქნება  ახალი პოსტის შექმნის შესაძლებლობა ={ 
  const createPost = async ()=>{
   return await create(newPost)
  } ;

  return (
  <>
      <Form animation={animation} id="postform" className="add-post">
      <h3>Add New Post</h3>

      <div className="line-cont">
        <label htmlFor="owner">You Name:</label>
        <input
          id="owner"
          onChange={(e) => setNewPost({ ...newPost, owner: e.target.value })}
          value={newPost.owner}
          type="text"
          placeholder="Name"
        />
      </div>

      <div className="line-cont">
        <label htmlFor="email">You Email:</label>{" "}
        <input
          id="email"
          onChange={(e) => setNewPost({ ...newPost, email: e.target.value })}
          value={newPost.email}
          type="email"
          placeholder="Email"
        />
      </div>

      <div className="line-cont">
        <label htmlFor="title">Post Title:</label>{" "}
        <input
          id="title"
          value={newPost.title}
          onChange={(e) => setNewPost({ ...newPost, title: e.target.value })}
          type="text"
          placeholder="Title"
        />
      </div>

      <div
        style={{
          width: "100%",
          display: "flex",
          flexDirection: "column",
          alignItems: "flex-start",
        }}
        className="line-cont"
      >
        <div style={{ display: "flex" }}>
          <label htmlFor="category">Select Category:</label>{" "}
          <label> {newPost.name}</label>
        </div>

        <div style={{ width: "100%" }}>
          <select
            onChange={(e) => setNewPost({ ...newPost, name: e.target.value })}
            value={newPost.name}
            className="select-category"
            name="Category"
            id="category"
          >
            <option value="not selected">select</option>
            <option value="About Me">About Me</option>
            <option value="About Project">About Project</option>
            <option value="Web Developers">Web Developers</option>
            <option value="Feedback">Feedback</option>
            <option value="Tag a user">Tag user</option>
          </select>
        </div>
      </div>

      <div
        style={{
          display: "flex",
          justifyContent: "center",
          textDecoration: "underline",
        }}
        className="line-cont"
      >
        <label style={{ width: "auto", flexGrow: "0" }} htmlFor="">
          Srt Pin:
        </label>{" "}
        <input
          style={{
            width: "auto",
            flexGrow: "0",
            boxShadow: "none",
            cursor: "pointer",
          }}
          type="checkBox"
        />
      </div>

      <div className="line-cont write-post">
        <label style={{ flexGrow: "0" }} htmlFor="postInput">
          Wrait Post:
        </label>
        <div style={{ width: "100%" }}>
          <textarea
            value={newPost.post}
            onChange={(e) => setNewPost({ ...newPost, post: e.target.value })}
            style={{ flexGrow: "1" }}
            id="postInput"
            placeholder="Write Post ..."
          />
        </div>
      </div>

      <div className="btn-cont">
        <button 
        onClick={createPost}
        // onClick={handleSubmit}
        >Add Post</button>
      </div>
    </Form>

  </>
  );
};
export default NewPost;  => const create = async (newPost: any) => {
    try {
      const accessToken = localStorage.getItem("accessToken");
  
      if (!accessToken) {
        throw new Error("Unauthorized: No access token available.");
      }
  
      const response = await fetch("http://127.0.0.1:8000/api/posts/", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${accessToken}`
        },
        body: JSON.stringify(newPost),
      });
  
      if (!response.ok) {
        if (response.status === 401) {
          throw new Error("Unauthorized: Invalid or expired token.");
        }
        throw new Error("Failed to create post.");
      }
  
      const data = await response.json();
      console.log("Post created:", data);
      return data;
  
    } catch (error) {
    //   console.error("Error creating post:", error.message);
    }
  };

  export default create;
    }   => ახლა გგანვიხილოთ პროექტის უკამნა ნაწილი რომელიც ამ ეტაპზე Blog კომპონენტს  ესა რის ჯანგოს პროექტი როელსიც რესტ ფერიმწორკისა და allauth  აპლიკაციების ინტეგრირებით ის ემსახურება მომხმარების ავტორიზატიის გერისტრაციისია და ვერიფიკაციის მოთხოვნებს => {from pathlib import Path

# Build paths inside the project like this: BASE_DIR / 'subdir'.
BASE_DIR = Path(__file__).resolve().parent.parent


# Quick-start development settings - unsuitable for production
# See https://docs.djangoproject.com/en/5.1/howto/deployment/checklist/

# SECURITY WARNING: keep the secret key used in production secret!
SECRET_KEY = 'django-insecure-+j+idkxaz!765zswytzilv^1@ru%e_#rx#cej4(m@zwsqtcx%r'

# SECURITY WARNING: don't run with debug turned on in production!
DEBUG = True

# ALLOWED_HOSTS = ['*.vercel.app']
ALLOWED_HOSTS = []
# ALLOWED_HOSTS = ['portfolio-backend-151yx5eav-roland-artmeladzes-projects.vercel.app', 'localhost']



# Application definition

INSTALLED_APPS = [
    'allauth',
    'allauth.account',
    'allauth.socialaccount',
    'allauth.socialaccount.providers.google',
    'django.contrib.admin',
    'django.contrib.auth',
    'django.contrib.contenttypes',
    'django.contrib.sessions',
    'django.contrib.messages',
    'django.contrib.staticfiles',
    'corsheaders',
    'rest_framework',
    'rest_framework.authtoken',
    'rest_framework_simplejwt',
    'blog',
]

# AUTH_USER_MODEL = 'blog.CustomUser'


MIDDLEWARE = [
    'corsheaders.middleware.CorsMiddleware',
    'django.middleware.security.SecurityMiddleware',
    'django.contrib.sessions.middleware.SessionMiddleware',
    'django.middleware.common.CommonMiddleware',
    'django.middleware.csrf.CsrfViewMiddleware',
    'django.contrib.auth.middleware.AuthenticationMiddleware',
    'django.contrib.messages.middleware.MessageMiddleware',
    'django.middleware.clickjacking.XFrameOptionsMiddleware',
    'allauth.account.middleware.AccountMiddleware',
]


REST_FRAMEWORK = {
    'DEFAULT_AUTHENTICATION_CLASSES': [
        # 'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.TokenAuthentication',
        'rest_framework.authentication.SessionAuthentication',
        'rest_framework_simplejwt.authentication.JWTAuthentication',
    ],
    'DEFAULT_PERMISSION_CLASSES': [
        # 'rest_framework.permissions.IsAuthenticatedOrReadOnly',
        'rest_framework.permissions.AllowAny',
    ],
}


SIMPLE_JWT = {
    'ACCESS_TOKEN_LIFETIME': timedelta(minutes=5),
    'REFRESH_TOKEN_LIFETIME': timedelta(days=1),
    'ROTATE_REFRESH_TOKENS': True,
    'BLACKLIST_AFTER_ROTATION': True,
    'ALGORITHM': 'HS256',
    'SIGNING_KEY': SECRET_KEY,
    'VERIFYING_KEY': None,
    'AUTH_HEADER_TYPES': ('Bearer',),
}



ROOT_URLCONF = 'PortfolioBackend.urls'

CORS_ALLOWED_ORIGINS = [
    "http://localhost:3000",
]

CORS_ALLOW_ALL_ORIGINS = True
CORS_ALLOW_CREDENTIALS = True

CSRF_COOKIE_SECURE = False



TEMPLATES = [
    {
        'BACKEND': 'django.template.backends.django.DjangoTemplates',
        'DIRS': [],
        'APP_DIRS': True,
        'OPTIONS': {
            'context_processors': [
                'django.template.context_processors.debug',
                'django.template.context_processors.request',
                'django.contrib.auth.context_processors.auth',
                'django.contrib.messages.context_processors.messages',
            ],
        },
    },
]

WSGI_APPLICATION = 'PortfolioBackend.wsgi.application'


# Database
# https://docs.djangoproject.com/en/5.1/ref/settings/#databases

DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.sqlite3',
        'NAME': BASE_DIR / 'db.sqlite3',
    }
}


# Password validation
# https://docs.djangoproject.com/en/5.1/ref/settings/#auth-password-validators

AUTH_PASSWORD_VALIDATORS = [
    {
        'NAME': 'django.contrib.auth.password_validation.UserAttributeSimilarityValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.MinimumLengthValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.CommonPasswordValidator',
    },
    {
        'NAME': 'django.contrib.auth.password_validation.NumericPasswordValidator',
    },
]


# Internationalization
# https://docs.djangoproject.com/en/5.1/topics/i18n/

LANGUAGE_CODE = 'en-us'

TIME_ZONE = 'UTC'

USE_I18N = True

USE_TZ = True


# Static files (CSS, JavaScript, Images)
# https://docs.djangoproject.com/en/5.1/howto/static-files/

# ALLOWED_HOSTS = ['*.vercel.app']


STATIC_URL = 'static/'

STATIC_ROOT = os.path.join(BASE_DIR, 'staticfiles')

MEDIA_URL = '/media/'
MEDIA_ROOT = os.path.join(BASE_DIR, 'media')

# Default primary key field type
# https://docs.djangoproject.com/en/5.1/ref/settings/#default-auto-field

DEFAULT_AUTO_FIELD = 'django.db.models.BigAutoField'



AUTHENTICATION_BACKENDS = (
    'django.contrib.auth.backends.ModelBackend',
    'allauth.account.auth_backends.AuthenticationBackend',
)

SITE_ID = 1

LOGIN_REDIRECT_URL = '/'
ACCOUNT_LOGOUT_ON_GET = True  

SOCIALACCOUNT_PROVIDERS = {
    'google': {
        'SCOPE': [
            'profile',
            'email',
        ],
        'AUTH_PARAMS': {
            'access_type': 'online',
        },
    }
}

# Optional: Customize allauth settings
ACCOUNT_EMAIL_REQUIRED = True
ACCOUNT_USERNAME_REQUIRED = False
ACCOUNT_AUTHENTICATION_METHOD = 'email'  => """
URL configuration for PortfolioBackend project.

The `urlpatterns` list routes URLs to views. For more information please see:
    https://docs.djangoproject.com/en/5.1/topics/http/urls/
Examples:
Function views
    1. Add an import:  from my_app import views
    2. Add a URL to urlpatterns:  path('', views.home, name='home')
Class-based views
    1. Add an import:  from other_app.views import Home
    2. Add a URL to urlpatterns:  path('', Home.as_view(), name='home')
Including another URLconf
    1. Import the include() function: from django.urls import include, path
    2. Add a URL to urlpatterns:  path('blog/', include('blog.urls'))
"""
from django.contrib import admin
from django.urls import path, include

urlpatterns = [
    path('admin/', admin.site.urls),
    path('api/', include('blog.urls')),
    path('accounts/', include('allauth.urls')),
]  ==> Blog =>  from django.contrib import admin
from .models import Posts, Comment

admin.site.register(Posts)
admin.site.register(Comment)
  => from django.db import models
from django.db.models import F
from django.db.models.signals import post_save, post_delete
from django.dispatch import receiver
from django.contrib.auth.models import User


def get_all_users():
    return User.objects.all()

class Posts(models.Model):
    author = models.ForeignKey(User, on_delete=models.CASCADE)
    title = models.CharField(max_length=200)
    post_id = models.AutoField(primary_key=True)
    name = models.CharField(max_length=200)
    owner = models.CharField(max_length=100)
    post = models.TextField()
    email = models.EmailField()

    created_at = models.DateTimeField(auto_now_add=True)
    updated_at = models.DateTimeField(auto_now=True)

    comment_count = models.IntegerField(default=0, editable=False)
    views = models.IntegerField(default=0, editable=False)
    share_count = models.IntegerField(default=0, editable=False)

    def __str__(self):
        return self.title

    # Method should be indented within the class
    def increment_views(self):
        self.views = F('views') + 1
        self.save(update_fields=['views'])
        self.refresh_from_db()

    def increment_comment_count(self):
        self.comment_count = F('comment_count') + 1
        self.save(update_fields=['comment_count'])
        self.refresh_from_db()

    def increment_share_count(self):
        self.share_count = F('share_count') + 1
        self.save(update_fields=['share_count'])
        self.refresh_from_db()


class Comment(models.Model):
    post = models.ForeignKey(Posts, related_name='comments', on_delete=models.CASCADE)
    name = models.CharField(max_length=50)
    comment = models.TextField()
    created_at = models.DateTimeField(auto_now_add=True)

    def __str__(self):
        return f'Comment by {self.name} on {self.post.title}'


@receiver(post_save, sender=Comment)
@receiver(post_delete, sender=Comment)
def update_comment_count(sender, instance, **kwargs):
    post = instance.post
    post.comment_count = post.comments.count()
    post.save()  => from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework import serializers
from django.contrib.auth import authenticate
from .models import Posts, Comment
from django.contrib.auth.models import User

class CommentSerializer(serializers.ModelSerializer):
    class Meta:
        model = Comment
        fields = ['post', 'name', 'comment', 'created_at']



class LoginSerializer(serializers.Serializer):
    username = serializers.CharField(required=True)
    password = serializers.CharField(write_only=True, required=True)

    def validate(self, data):
        username = data.get('username')
        password = data.get('password')

        if username and password:
            user = authenticate(username=username, password=password)
            if user is None:
                raise serializers.ValidationError("Invalid username or password")
        else:
            raise serializers.ValidationError("Must include both username and password")

        return data  



# class LoginSerializer(serializers.Serializer):
#     username = serializers.CharField(required=True)
#     password = serializers.CharField(write_only=True, required=True)

#     def validate(self, data):
#         username = data.get('username')
#         password = data.get('password')

#         if username and password:
#             user = authenticate(username=username, password=password)
#             if not user:
#                 raise serializers.ValidationError("Invalid username or password")
#         else:
#             raise serializers.ValidationError("Must include both username and password")

#         refresh = RefreshToken.for_user(user)
#         return {
#             'refresh': str(refresh),
#             'access': str(refresh.access_token),
#             'username': user.username,
#             'email': user.email,
#             'lastname': user.last_name,
#             'firstname': user.first_name
#         }

class RegisterSerializer(serializers.ModelSerializer):
    password = serializers.CharField(write_only=True)
    password2 = serializers.CharField(write_only=True)

    class Meta:
        model = User
        fields = ['username', 'first_name', 'last_name', 'email', 'password', 'password2']

    def validate(self, data):
        if data['password'] != data['password2']:
            raise serializers.ValidationError({"password": "Passwords must match."})
        return data

    def create(self, validated_data):
        user = User.objects.create_user(
            username=validated_data['username'],
            email=validated_data['email'],
            password=validated_data['password']
        )
        return user

class PostsSerializer(serializers.ModelSerializer):
    comments = CommentSerializer(many=True, read_only=True)

    class Meta:
        model = Posts
        fields = ['post_id', 'author', 'name', 'owner', 'title', 'post', 'email', 'created_at', 'updated_at', 'comment_count', 'views', 'share_count', 'comments']
        read_only_fields = ['author', 'comment_count', 'views', 'share_count', 'created_at', 'updated_at']

    def create(self, validated_data):
        request = self.context.get('request')

        # Check if user is authenticated
        if not request or not request.user.is_authenticated:
            raise serializers.ValidationError('User must be authenticated to create a post.')

        validated_data['author'] = request.user
        
        return Posts.objects.create(**validated_data)

class UserSerializer(serializers.ModelSerializer):
    class Meta: 
        model = User
        fields = '__all__' => from django.urls import path, include
from rest_framework.routers import DefaultRouter
from .views import (
    PostsViewSet, 
    CommentViewSet, 
    UserViewset, 
    RegisterView, 
    LogoutView, 
    LoginView,
    profile_view
    )
from rest_framework_simplejwt.views import (
    TokenObtainPairView,
    TokenRefreshView,
)
# Create a router for ViewSets
router = DefaultRouter()
router.register(r'posts', PostsViewSet)
router.register(r'comments', CommentViewSet)
router.register(r'users', UserViewset)

urlpatterns = [
    path('register/', RegisterView.as_view(), name='register'),
    path('logout/', LogoutView.as_view(), name='logout'),
    path('login/', LoginView.as_view(), name='login'), 
    path('token/', TokenObtainPairView.as_view(), name='token_obtain_pair'),
    path('token/refresh/', TokenRefreshView.as_view(), name='token_refresh'),  
    path('profile/', profile_view, name='profile'),
    path('', include(router.urls)),
]    => როგორ შემიძლია დავამატო გუგლით ან სხვა პროვაიდერით  ავტორიზებილი მომხმარებლების სტანდატრული პროფილის მონაცემების ნახვა ისეთის როგორიცაა პროფილის ავატარი ან ასაკი სახელი მეიი და აშ. => import logging

from rest_framework_simplejwt.tokens import RefreshToken
from rest_framework.permissions import IsAuthenticatedOrReadOnly , IsAuthenticated
from rest_framework import views, viewsets, status, serializers, permissions
from rest_framework.response import Response 

from django.shortcuts import render
from rest_framework.authtoken.views import ObtainAuthToken, APIView
from rest_framework.authtoken.models import Token

from rest_framework.response import Response
from django.contrib.auth import authenticate, login

from .models import Posts, Comment
from .serializers import PostsSerializer, CommentSerializer, UserSerializer, RegisterSerializer, LoginSerializer
from django.contrib.auth.models import User

from django.contrib.auth.decorators import login_required


logger = logging.getLogger(__name__)






class LoginView(APIView):
    def post(self, request):
        serializer = LoginSerializer(data=request.data)
        if serializer.is_valid():
            user = authenticate(username=serializer.validated_data['username'], password=serializer.validated_data['password'])
            if user:
                refresh = RefreshToken.for_user(user)
                logger.info(f"User {user.username} logged in successfully.")
                return Response({
                    'refresh': str(refresh),
                    'access': str(refresh.access_token),
                    'username': user.username,
                    'email': user.email,
                    'lastname': user.last_name,
                    'firstname': user.first_name,
                    'id': user.id,
                }, status=status.HTTP_200_OK)
            else:
                logger.warning("Authentication failed: Invalid credentials.")
                return Response({"error": "Invalid username or password"}, status=status.HTTP_401_UNAUTHORIZED)
        logger.error("Validation failed: %s", serializer.errors)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)









class LogoutView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            token = Token.objects.get(user=request.user)
            token.delete()  # Delete the token to log out
            return Response({"detail": "Successfully logged out."}, status=status.HTTP_200_OK)
        except Token.DoesNotExist:
            return Response({"detail": "Token does not exist."}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)



# class LoginView(APIView):
#     def post(self, request):
#         serializer = LoginSerializer(data=request.data)
#         if serializer.is_valid():
#             return Response(serializer.validated_data, status=status.HTTP_200_OK)
#         return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    
    


# class LogoutView(APIView):
    
#     permission_classes = [IsAuthenticated]

#     def post(self, request):
#         logger.info(f"User {request.user} is logging out.")
#         try:
#             request.user.auth_token.delete()  
#             return Response({"message": "User logged out successfully"}, status=status.HTTP_200_OK)
#         except Exception as e:
#             logger.error(f"Error during logout: {str(e)}")
#             return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


class RegisterView(APIView):
    def post(self, request):
        serializer = RegisterSerializer(data=request.data)
        if serializer.is_valid():
            serializer.save()
            return Response({"message": "User created successfully"}, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


class UserViewset(viewsets.ModelViewSet):
    queryset = User.objects.all()
    serializer_class = UserSerializer


class PostsViewSet(viewsets.ModelViewSet):
    queryset = Posts.objects.all()
    serializer_class = PostsSerializer
    permission_classes = [permissions.IsAuthenticatedOrReadOnly]

    # permission_classes = [IsAuthenticated]

class CommentViewSet(viewsets.ModelViewSet):
    queryset = Comment.objects.all()
    serializer_class = CommentSerializer


# class CustomAuthToken(APIView):
#     def post(self, request, *args, **kwargs):
#         serializer = LoginSerializer(data=request.data)
#         serializer.is_valid(raise_exception=True)

#         user = serializer.validated_data['user']

#         refresh = RefreshToken.for_user(user)

#         return Response({
#             'refresh': str(refresh),
#             'access': str(refresh.access_token),
#             'username': user.username,
#             'email': user.email,
#             'lastname': user.last_name,
#             'firstname': user.first_name
#         }, status=status.HTTP_200_OK)





@login_required
def profile_view(request):
    user = request.user
    context = {
        'email': user.email,
        'first_name': user.first_name,
        'last_name': user.last_name,
        'id': user.id,
        # Add other fields if needed
    }
    return render(request, 'profile.html', context) =>  
    
    მემგონი სულ ეს არის რისი თქმაც მინდოდა მომაწოდე დეტალირი განხილვა როგორ მოშაობს,  შედარება  იმასთან რაც არის საუკეთესო პრაქტიკა რიდმი ფაილის მომზადების ანალიზი და წარმოადგნე ისე რო ერთგვარად შევძო ჩემი პროექტის სიღრმისეული პრეზენტირება წარდგენა   . 

  ასევე დვამატებ პროექტის წინა და უკანა ნაწილის რეადმე ფაილებს == .{# React TypeScript Portfolio Project with Django Backend

This project is a personal portfolio and blog application built with **React** and **TypeScript** on the frontend and **Python** with **Django** and **Django REST Framework** on the backend. The portfolio showcases my projects, skills, and blog posts, with a focus on dynamic content and API-based interactions.

## Features

- **Portfolio Section**: Showcases my projects, skills, and experiences.
- **Blog Section**: Users can read and add blog posts, leave comments, and interact with posts.
- **Dynamic Content**: Data is fetched from the Django REST API to display posts and comments in real-time.
- **Responsive Design**: The UI is optimized for desktop, tablet, and mobile screens.
- **Backend**: Built with Django and Django REST Framework to provide APIs for the frontend.
- **Authentication**: User authentication system (optional) to manage post creation and comment interaction.

## Technologies Used

### Frontend
- **React**: A JavaScript library for building user interfaces.
- **TypeScript**: Strongly typed superset of JavaScript for scalability and type safety.
- **Axios**: To make API requests to the Django backend.
- **SCSS**: For styling the UI with a modular and maintainable approach.

### Backend
- **Python**: Backend logic written in Python.
- **Django**: The web framework used to build the backend, including the blog and portfolio APIs.
- **Django REST Framework**: Provides the APIs for managing posts, comments, and users.
- **SQLite**: The database used for development (can be switched to PostgreSQL or other databases for production).

## Getting Started

### Prerequisites

- **Node.js**: Install from [https://nodejs.org/](https://nodejs.org/)
- **Python**: Install from [https://www.python.org/](https://www.python.org/)
- **Django**: Install using `pip install django`
- **Django REST Framework**: Install using `pip install djangorestframework`

### Frontend Setup

_____________ ...
 }  {# Django Django Backend Project

## Project Overview
<p>
  This Django backend project provides an API for interacting with a database using the Django REST framework. It supports creating, reading, updating, and deleting (CRUD) operations through the API and offers an admin panel for managing the database.
</p>


### Features
Django REST Framework: Enables API creation for data handling. <br />
Data Handling: Supports data input, retrieval, and management from a frontend application. <br />
Admin Panel: Provides an interface for managing database records directly. <br />
Installation
Follow these steps to set up the project on your local machine:

### Clone the Repository:
git clone [https://[(https://github.com/rolandiartmeladze/PortfolioBackend.git)]](https://github.com/rolandiartmeladze/PortfolioBackend.git) <br />
cd PortfolioBackend<br />

##Create and Activate Virtual Environment:

python -m venv env <br /> 
source env/bin/activate  

# Install Dependencies:

pip install -r requirements.txt

## Set Up the Database:

### Run the following commands to apply migrations:

python manage.py migrate <br />

### If necessary, create a superuser for the admin panel:

python manage.py createsuperuser

## Run the Development Server:

python manage.py runserver <br />
The server will be available at http://127.0.0.1:8000/.

## API Endpoints
### The project provides the following REST API endpoints:

GET/POST /api/posts/: Retrieve a list of all records. <br />
POST/GET /api/comments//: Create a new record. <br />
GET /admin/: Retrieve a specific record by its ID. user: admin  Pass:admin <br />

## Admin Panel
Access the admin panel at http://127.0.0.1:8000/admin/ to manage the database using the credentials you set up earlier.

# Deployment
Instructions for deploying the project to a production environment, such as setting up on Vercel, will go here.

# Contributing
If you'd like to contribute, please fork the repository and use a feature branch. Pull requests are welcome.

# License
This project is open-source and available under the MIT License.
}






















class LogoutView(APIView):
    permission_classes = [IsAuthenticated]

    def post(self, request):
        try:
            token = Token.objects.get(user=request.user)
            token.delete()  # Delete the token to log out
            return Response({"detail": "Successfully logged out."}, status=status.HTTP_200_OK)
        except Token.DoesNotExist:
            return Response({"detail": "Token does not exist."}, status=status.HTTP_400_BAD_REQUEST)
        except Exception as e:
            return Response({"error": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
 => write frontend request with logout => Login
POST /api/login/
HTTP 400 Bad Request
Allow: POST, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "detail": "JSON parse error - Expecting ':' delimiter: line 1 column 14 (char 13)"
}

Media type:
application/json
Content:
{
"username" : "rartmeladze@gmail.com", 
"password" : " admin",
}  => Login
POST /api/login/
HTTP 200 OK
Allow: POST, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "refresh": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoicmVmcmVzaCIsImV4cCI6MTcyNzY3NzU0MiwiaWF0IjoxNzI3NTkxMTQyLCJqdGkiOiJlYzQ1YzVkNThhMTc0ZmZlODZhZDhjODkzNjBmMTk4ZCIsInVzZXJfaWQiOjF9.waQ12CH6NSk-xc4crGc4UVZYQBcDp-n6y-8okJ1XBLk",
    "access": "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ0b2tlbl90eXBlIjoiYWNjZXNzIiwiZXhwIjoxNzI3NTkxNDQyLCJpYXQiOjE3Mjc1OTExNDIsImp0aSI6IjFjOWQ2N2UyNzI2NDRhZjZhZDkyOWQ5MmQ3NjkzMjMzIiwidXNlcl9pZCI6MX0.NAtMiuKEwfnKo0ruds_NspZbpB_alX1KOqHAnQD2T-0",
    "username": "admin",
    "email": "rartmeladze@gmail.com",
    "lastname": "Artmeladze",
    "firstname": "Roland",
    "id": 1
}  => Logout
GET /api/logout/
HTTP 405 Method Not Allowed
Allow: POST, OPTIONS
Content-Type: application/json
Vary: Accept

{
    "detail": "Method \"GET\" not allowed."
}

Media type:
application/json
Content:
